# Оптимизация запросов и план БД
Примеры и эксперименты с реальной таблицей проекта доступны в examples.sql

## Полезные ссылки

### Оптимизация производительности запросов:
- https://postgrespro.ru/docs/postgrespro/9.5/performance-tips

### Журналирование (можно оптимизировать)
- https://postgrespro.ru/docs/postgrespro/9.5/runtime-config-wal

### Настройка сервера - планирование запроса:
- https://postgrespro.ru/docs/postgrespro/9.5/runtime-config-query

### Explain. Объясняя необъеснимое:
- https://habr.com/ru/articles/275851/
- https://habr.com/ru/articles/276973/
- https://habr.com/ru/articles/279255/

### Материалы с обучающего ресурса:
- https://edu.postgrespro.ru/qpt/


## Своими словами

### Влияение на скорость запроса:
- Настройка параметров PostgreSQL:
  - Конфигурация коэффициентов и параметров влияющих на план запроса
- Настройка структуры таблиц
  - Оптимизировать Индексы(правильный выбор типа индекса - b-tree, хэш, etc)
  - Использовать частичный индекс
- Конфигурация запроса
  - Явные джойны (join_collapse_limit = 1)
  - Сокращение обращений в БД
  - Сортировки
  - Аггрегирования
  - Правильное Использование индексных полей в запросах (%пп% - нельзя, 'пп%'-можно)
  - Уменьшение объема данных
- Скорость соединения с БД

### Когда нужны индексы:
- Мало данных - индекс не нужен
- Много данных и нужно больше половины выбрать - индекс не нужен
- Много данных - выбор меньше части данных - нужен индекс
- Много данных - но используем, например только за тек месяц - нужен частичный индекс

Также важен балланс т.к. наличие индексов влияет на операции всавки и обновления.

### EXPLAIN
```
Дерево узлов плана, которое строится таким образом, чтобы сократить стоимость запроса
Без ANALIZE - считает план на основе статистики

cost = (число_чтений_диска * seq_page_cost) + (число_просканированных_строк * cpu_tuple_cost)
По умолчанию^
seq_page_cost равно 1.0, 
cpu_tuple_cost — 0.01, 
так что приблизительная стоимость запроса равна (358 * 1.0) + (10000 * 0.01) = 458.

(cost=0.55..134.39 rows=5 width=103) (actual time=0.149..0.661 rows=153 loops=1)
cost 0.55 - стоимость возврата первой строки
cost 134.39- стоимость возврата выбранных строк
rows - кол-во строк
width - средний размер строк в байтах
time 0.149 - реальное время возврата первой строки
time 0.661 - реальное время возврата выбранных строк
loops - количество запусков операций, другие значения (строки, время) 
являются средними показателями для всех запусков.
Статистика обновляется командами ANALIZE, CREATE INDEX
Статистика содержит кол-во строк, условия выбора
```

### Описание узлов плана:
- Seq Scan - последовательное сканирование
- Filter - фильтр строк
- Rows Removed by Filter - строк не попало в фильтр
- Index Scan - индексное сканирование
- Index Scan Backward - индекскное сканирование по убыванию
- Index Cond - условие по индексу
- Index Only Scan - выбипаем индексную колонку и не нужно обращаться к таблице
- Bitmap Index Scan - создание битовой карты 
(проставляются 1 на страницах с нужными данными, 0 - по умолчанию. Данные в таблице не затрагиваются.)
- Bitmap Heap Scan - получает карту от Bitmap Index Scan и делает выборку данных
- Recheck Cond - перепроверка условий
- BitmapOr, BitmapAnd, BitmapNot - логические операции с битовыми картами для совмещения условий поиска.

- Function Scan - при вызове функций которые возвращают множество записей
- Sort - сортировка! используется ограничение памяти work_mem, если превышен порог, то переключение на дисковую память
  - Sort Method: quicksort  Memory: 998kB
  - Sort Method: external merge  Disk: 264kB
  - Если используется Limit Sort Method: top-N heapsort  Memory: 26kB (Использует меньше памяти за счет ограничения кол-ва строк)
- Limit - возвращает первые N строк из субоперации
- HashAggregate: GROUP BY sum(), avg(), min(), max() etc, использует work_mem
```
Сканирует все строки, собирает словарь данных, пробегается по словарю и 
выполяет операцию аггрегации для каждой корзины.
```
- Hash Join / Hash
```
Вызывается Hash, который собирает данные таблицы1 по ключам в словарь.
(в памяти или на диске, в зависимости от размера).
Далее сканируем данные таблицы2 и ищем соответствие строк с ключем в хэше
Если ключ существует, Hash Join берет строки из хэша и, основываясь на этой строке, 
с одной стороны, и всех строках хэша, с другой стороны, генерирует вывод строк.
```
- Nested Loop - вложенный цикл из двух операций Seq Scan, Index Scan
- Merge Join - объединение отсортированных наборов (при наличие двух отсортированных массивов)
- Materialize - сохраняет данные или дополняет до нужного контракта (для последующего обращения)
```
Получает данные из нижележащей операции и размещает их в памяти 
(или частично в памяти), чтобы ими можно было быстрее воспользоваться, 
или добавляет им дополнительные свойства, которые предыдущая операция не 
предоставляет.
```
- Heap Fetches — при индексном сканировании обращение в кучу для получения 
метаданных о строке (метаданные не хранятся в индексе) 
```
это обращения к основной таблице (heap) для проверки видимости строк, 
которые происходят даже при использовании индекса. 
Чтобы минимизировать их, необходимо регулярно выполнять VACUUM, 
обновлять статистику таблицы и использовать покрывающие индексы.
```
- Heap Blocks: exact=1 - количестов обращений к блокам данных в куче 
(чем меньше, тем лучше сбалансированны данные)
### Потребление ресурсов - память ! важный параметр
- work_mem (integer)
```
Задаёт объём памяти, который будет использоваться для внутренних 
операций сортировки и хеш-таблиц, прежде чем будут задействованы временные файлы 
на диске. Значение по умолчанию — четыре мегабайта (4MB). 
Заметьте, что в сложных запросах одновременно могут выполняться несколько 
операций сортировки или хеширования, так что этот объём памяти будет доступен 
для каждой операции. Кроме того, такие операции могут выполняться одновременно в разных сеансах. 
Таким образом, общий объём памяти может многократно превосходить значение work_mem; 
это следует учитывать, выбирая подходящее значение. Операции сортировки используются 
для ORDER BY, DISTINCT и соединений слиянием. Хеш-таблицы используются при 
соединениях и агрегировании по хешу, а также обработке подзапросов IN с 
применением хеша.
```

### Оптимизация наполнения БД по скорости:
- 14.4.1. Отключите автофиксацию транзакций
- 14.4.2. Используйте COPY
- 14.4.3. Удалите индексы
- 14.4.4. Удалите ограничения внешних ключей
- 14.4.5. Увеличьте maintenance_work_mem
- 14.4.6. Увеличьте max_wal_size
- 14.4.7. Отключите архивацию WAL и потоковую репликацию
- 14.4.8. Выполните в конце ANALYZE
- 14.4.9. Несколько замечаний относительно pg_dump


### Конфигурация параметров выполнения запросов
Выставляя значения параметров конфигуратора планировщика, 
статистики можно грубо влиять на выполнение плана запроса.

#### Конфигурация методов планировщика
```
enable_bitmapscan (boolean)
Включает или отключает использование планов сканирования по битовой карте. По умолчанию имеет значение on (вкл.).

enable_hashagg (boolean)
Включает или отключает использование планов агрегирования по хешу. По умолчанию имеет значение on (вкл.).

enable_hashjoin (boolean)
... 
Подробности см. в документации.
```

#### Константы стоимости для планировщика
```
seq_page_cost (floating point)
Задаёт приблизительную стоимость чтения одной страницы с диска, которое 
выполняется в серии последовательных чтений. Значение по умолчанию равно 1.0. 

random_page_cost (floating point)
Задаёт приблизительную стоимость чтения одной произвольной страницы с диска.
... 
Подробности см. в документации.
```

#### Генетический оптимизатор запросов
```
geqo (boolean)
Включает или отключает генетическую оптимизацию запросов. 
По умолчанию она включена. В производственной среде её лучше не отключать; 
более гибко управлять GEQO можно с помощью переменной geqo_threshold.

geqo_threshold (integer)
Задаёт минимальное число элементов во FROM, при котором для планирования 
запроса будет привлечён генетический оптимизатор.
... 
Подробности см. в документации.
 ```

#### Другие параметры планировщика

```
from_collapse_limit (integer)
Задаёт максимальное число элементов в списке FROM, до которого планировщик будет 
объединять вложенные запросы с внешним запросом

join_collapse_limit (integer)
Задаёт максимальное количество элементов в списке FROM, 
до достижения которого планировщик будет сносить в него явные конструкции JOIN 
При меньших значениях сокращается время планирования, но план запроса может 
стать менее эффективным.
... 
Подробности см. в документации.
```
### Получить текущие параметры БД
```
SHOW ALL;

SELECT name, setting, unit, short_desc
FROM pg_settings
WHERE name IN (
'work_mem', 'from_collapse_limit', 'join_collapse_limit', 'geqo_threshold'
);

Назначить параметр
SET work_mem = 8;
```
