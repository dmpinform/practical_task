## SqlAlchemy ORM, Events
*** 
### ORM:
- Приведены примеры императивного и декларативного мапинга
- Декларативный мапинг синтетический, реализован в стиле 2.0
- Императивный мапинг приведен из проекта
- В мапинге используются полиморфные связи, наследование двух видов: 
  в одной таблице и таблицей "родителем" с расширением свойств в "дочерних" таблицах.

Применение мапинга и объектного подхода в разработке приложения должно быть оправдано и обосновано.
Следует комбинировать core и orm подходы.

### Маппинг на словари (Dictionary Collections SQLAlchemy 2.0) :
Используется как альтернатива спискам и множествам (list, set).
Удобно для группировки дочерних записей по ключевому атрибуту.
Есть несколько стратегий определения ключевого атрибута, но чаще и 
удобней использовать attribute_keyed_dict.
#### Коллекция словарей с атрибутом в качестве ключа
 - attribute_keyed_dict("keyword")
#### Коллекция словарей со столбцом в качестве ключа
 - column_keyed_dict(Note.__table__.c.keyword)
#### Коллекция словарей с функцией в качестве ключа
- keyfunc_mapping(lambda prop: prop.id,)
#### !Ключевые мутации и обратное заполнение
- изменение ключа не отслеживается - ключ назначается при его первом использовании, 
и если ключ поменяется, то коллекция не будет изменена.
- Ключ, основанный на изменяемых свойствах, может привести к «потере» недоступных экземпляров в коллекции.
- Это может быть проблемой при назначение ключевого атрибута после присваивания 
```
a1 = A() # родитель
b1 = B(a=a1) # ребенок со ссылкой на родителя
a1.bs # ключевой атрибут пока не назначен

b1.data = "the key" # назначение ключа не обновит коллекцию
a1.bs # ключевой атрибут по прежнему не назначен
```
- Также важен порядок атрибутов
```
B(a=a1, data="the key") # нет ключа
B(data="the key", a=a1) # есть ключ
```
- для обеспечения консистентности объектов можно использовать листенер, 
который будет отслеживать изменение атрибута и обновлять коллекцию ключей в родительской сущности.
---------
Использование мапинга на словари удобно для встроенного хранения 
зависимостей в виде словаря и быстрого поиска по ключам. 
Думаю для связей "только для чтения" 
в некоторых случаях коллекции словарей хороший выход.

### Events:
- Приведены варианты использования событий ORM, core, connection.
- Применение пароля БД во время подключения.
- Глобальная фильтрация данных во свремя выполнения запроса.
- Перехват параметров запроса во время вополнения.

Можно применять для внедрения сквозной функциональности без модификации кода (фоном).

### Вариант применения:
На мой взгляд приложение может быть похоже на фреймворк под целевую предметную область, с учетом бизнес требований.
При таком подходе масштабирование и модификация упростятся, а сложность будет инкапсулирована в ядро приложения,
которое может быть построено c использованием ORM и events.
